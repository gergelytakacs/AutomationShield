"""
  MAGNETOSHIELD EXPLICIT MPC EXAMPLE

  WARNING: This is an experimental example and it does
            not work properly.

  This example uses the "empc" module for the online part of
  explicit model predictive control (EMPC, Explicit MPC). The
  "Sequential()" function implements a simple sequential search
  for the region with the current state, then computes the PWA
  control law associated with it. The sequential search algorithm
  has been re-written to Python based on the original found in the
  Multi-Parametric Toolbox (MPT) of Kvasnica et. al
  (see. http://www.mpt3.org). The definition of the controller
  itself is auto-generated by MPT in MATLAB, see the empcToPython.m
  function.

  Tested with the following boards
  - Adafruit Metro M4 Express (1)

  (1) Code runs, however, levitation is not achieved. The issue is timing,
  as the sequential search takes way too long to fit into the 5 ms
  sampling limit.

  If you have found any use of this code, please cite our work in your
  academic publications, such as theses, conference articles or journal
  papers. A list of publications connected to the AutomationShield
  project is available at:
  https://github.com/gergelytakacs/AutomationShield/wiki/Publications

  This code is part of the AutomationShield hardware and software
  ecosystem. Visit http://www.automationshield.com for more
  details. This code is licensed under a Creative Commons
  Attribution-NonCommercial 4.0 International License.

  Created by:       Gergely Takács
  Created on:       11.11.2020.
  Last updated by:  Gergely Takács
  Last update:      11.11.2020.
"""
import AutomationShield                         # Import the AutomationShield module
import MagnetoShield                            # Imports the MagnetoShield module for hardware functionality
import Sampling                                 # Imports the Sampling module for pseudo-real time sampling
import time                                     # Imports the time module for delays
import sys                                      # Imports system module to tell platform
import empc                                     # Imports explicit MPC online code

MANUAL = False                                  # Reference by pot (True) or automatically (False)?
DATA_OUTPUT = False                             # Only experiment (False) or with data dumped to serial (True)
PLOTTING_POST = False                           # Does not supply data while the experiment is running, only does it after it is finished
                                                # this helps Mu Plotter not to be flooded. You will only see Y and U plotted. As an alternative
                                                # use an external serial program like CoolTerm.

# Sampling rate
Ts = int(5000)                                  # [ms] Sampling in microseconds, lower limit unknown for the M4 Express

# Linearization points
y0 = 14.3                                       # [mm] Linearization point based on the experimental identification
I0 = 21.9                                       # [mA] Linearization point based on the experimental identification
u0 =  4.6234                                    # [V] Linearization point based on the experimental identification
yp = 0.0					                    # [mm] Previous output measurement

R = [14.0, 13.0, 14.0, 15.0, 14.0]              # [mm] Desired reference trajectory (pre-set)
T = int(1000)                                   # [steps] Experiment section length
r = R[0]                                        # Initial reference


X =  [0.0, 0.0, 0.0, 0.0]                       # Initial state vector
Xr = [0.0, 0.0, 0.0, 0.0]                       # Initial state reference

if PLOTTING_POST:                               # If the plotter of Mu is used, this speed will flood it, so plot it later.
    Ylog = []                                   # Empty list to store output results
    Ulog = []                                   # Empty list to store input results

k = int(1)                                      # Sample index
i = int(1)                                      # Experiment section counter

# Initialize and calibrate board
MagnetoShield.begin()                           # Lock I2C bus
MagnetoShield.calibration()                     # Calibrate device
Sampling.begin(Ts)                              # Initialize sampling subsystem (based on time.monotonic_ns())

# Algorithm step - every step that is necessary for control
def step():
    global yp, r, R, i, k, Ts                   # Access these global variables
    if MANUAL:                                  # If reference from potentiometer
        Xr[0] = AutomationShield.mapFloat(MagnetoShield.referenceRead(), 0.0, 100.0, 12.0, 17.0)
    else:                                       # if pre-set experiment
        if (k > (len(R) * T) - 1):              # if the experiment is overs
            Sampling.Settings.realTimeViolation = False  # Not a real-time violation
            MagnetoShield.actuatorWrite(0.0)    # then turn off magnet
            if DATA_OUTPUT:                     # if outputs are requested
                if PLOTTING_POST:                   # In case plotting in post is enabled
            	    for j in enumerate(Ylog):             # for every element in the log vector of outputs
                        print((Ylog[j[0]],Ulog[j[0]],))   # Print to serial
                        time.sleep(0.03)            # Wait a bit so that Mu plotter can catch up
            while True:                         # then stop
                pass                            # and do nothing
        else:                                   # if the experiment is not yet over
            if (k % (T*i) == 0):                # else for each section
    		    Xr[1] = (R[i]-y0)/1000.0    # set reference
                    r = R[i]                    # set reference
                    i += 1                      # and increase section counter for next

    y = MagnetoShield.sensorRead()              # [mm] sensor read routine
    I = MagnetoShield.auxReadCurrent()	        # [mA] Current read

# Direct state measurement with differentiation for speed
    X[0] = X[0] + (Xr[1] - X[1])                 	 	    # integrator
    X[1] = (y - y0) / 1000.0                        	 	# position calculated from measurement, compensated for linearization point, converted to [m]
    X[2] = (y - yp) / (1000.0 * (float(Ts) / 1000000.0)) 	# speed calculated using differentiation
    X[3] = (I - I0) / 1000.0                        	 	# current compensated for linearization point and converted to [A]
    yp = y                                      		    # at the end of the calculation current value becomes previous value for the next iteration

# LQ control algorithm
    U = empc.Sequential(X)                      # Call EMPCsequential search algorithm
    u = float(U[0]) + u0                        # Select first element, correct for linearization point

    MagnetoShield.actuatorWrite(u)              # [V] write input to actuator
    if DATA_OUTPUT:
        if PLOTTING_POST:                       # If we are plotting after the experiment
            Ylog.append(y)                      # append output y to output vector
            Ulog.append(u)                      # append input u to input vector
        else:                                   # otherwise we are plotting "real time"
            print((r, y, u))                    # send data to output and
    k += 1                                      # Increment time-step k

# Main loop launches a single step at each enable time
while True:                                     # Infinite loop
    Sampling.stepEnable()                       # Routine to enable the algorithm step, changes the flag Sampling.enable
    if Sampling.Settings.enable:                # If time comes
        step()                                  # Algorithm step
        Sampling.Settings.enable = False        # Then disable